<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
        <meta http-equiv="X-UA-Compatible" content="chrome=1">

        <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

        <title>Python DCPU-16 by lloeki</title>
    </head>

    <body>

        <header>
        <div class="container">
            <h1>Python DCPU-16</h1>
            <h2>DCPU-16 implementation in Python</h2>

            <section id="downloads">
            <a href="https://github.com/lloeki/python-dcpu_16/zipball/master" class="btn">Download as .zip</a>
            <a href="https://github.com/lloeki/python-dcpu_16/tarball/master" class="btn">Download as .tar.gz</a>
            <a href="https://github.com/lloeki/python-dcpu_16" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
            </section>
        </div>
        </header>

        <div class="container">
            <section id="main_content">
            <h3>What is this?</h3>

            <p>A DCPU-16 implementation in Python. See <a href="http://0x10c.com/doc/dcpu-16.txt">the spec</a>.</p>

            <h3>Goal</h3>

            <p>Many high-level implementations looked like C-in-other-language, so let's have a pythonic enough (whatever that means, but you should <a href="http://www.dabeaz.com/generators/">read</a> <a href="http://www.dabeaz.com/coroutines/">this</a>) implementation. The spirit of the thing is to be educative for everyone.</p>

            <h3>Usage</h3>

            <p>It's meant to be used interactively via the Python REPL as well as programmatically. A specific ASM REPL might be implemented at some point.</p>

            <p>An example of a Python REPL session:</p>

<pre><code>&gt;&gt;&gt; from dcpu_16 import CPU, spec_demo
&gt;&gt;&gt; c = CPU(debug=True)
&gt;&gt;&gt; c.load_m(spec_demo)         # loads demo program
&gt;&gt;&gt; c.step()                    # step by one instruction
 &lt;&lt; SET
 &lt;&lt; c.r[0x0]
 &lt;&lt; c.m[0x0001]
 &lt;&lt; A=0030 B=0000 C=0000 X=0000 Y=0000 Z=0000 I=0000 J=0000 PC=0002 SP=0000 O=0000
&gt;&gt;&gt; c.pc = 0xA                  # jump to 'loopy thing'
&gt;&gt;&gt; c.step()
 &lt;&lt; SET
 &lt;&lt; c.r[0x6]
 &lt;&lt; 0x000A
 &lt;&lt; A=0030 B=0000 C=0000 X=0000 Y=0000 Z=0000 I=000A J=0000 PC=000B SP=0000 O=0000
&gt;&gt;&gt; c.reset()                   # reset CPU
&gt;&gt;&gt; c.clear()                   # clear memory
&gt;&gt;&gt; c.dump_r()                  # get CPU register state as string
'A=0000 B=0000 C=0000 X=0000 Y=0000 Z=0000 I=0000 J=0000 PC=0000 SP=0000 O=0000'
</code></pre>

            <h3>Status</h3>

            <p>As of v1.0 the CPU implementation ought to be complete according to DCPU-16 spec v1.1.</p>

            <h3>Features</h3>

            <p>Opcodes and valcodes are as declarative as possible using decorators, leaving the dispatcher as a quasi-one-liner and leveraging <code>dict</code> power instead of <code>if</code>/<code>elif</code>.</p>

            <p>Using functions/methods mean there are doctrings everywhere, hence documentation is both very local and as exhaustive as possible. Try <code>help(dcpu_16)</code>.</p>

            <p>You can use <code>cpu[]</code> to dispatch valcodes and get/set directly without having to handle a pointer structure.</p>

            <p>The CPU is a class, so you can instantiate a bunch of them. I might move memory outside the CPU so that it would be shared by CPU instances (SMP!)</p>
            </section>
        </div>


    </body>
</html>
